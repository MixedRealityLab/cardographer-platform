# Cardographer data model

## Card authoring

A card deck is the unit of authoring.
There is a `CardDeckSummary` for each deck, with:
- `_id` (string/MongoDB ObjectID) - unique
- `name` (string) - denorm from latest revision (below)
- `description` (string) - denorm from latest revision
- `credits` (string) - denorm from latest revision
- `isPublic` (boolean)
- `owners` (string[]) - emails (or similar unique IDs of owners of the deck for RBAC)
- `currentRevision` (number) - from CardDeckRevision.revision

### Card Deck Revision

A card deck may go through several revisions.
A revision is basic unit of card deck use.
There is a `CardDeckRevision` for each revision, with:
- `_id` (string) - unique (card deck id plus revision number)
- `deckId` (string) - deck id
- `revision` (number) - auto-increment integer, starting at 1
- `slug` (string, optional) - file/URL component for revision
- `deckName` (string) - deck name
- `deckDescription` (string)
- `deckCredits` (string)
- `created` (ISO date string/MongoDB Date)
- `lastModified` (ISO date string/MongoDB Date)
- `revisionName` (string) - revision name (addition to deckName)
- `revisionDescription` (string) - specifically about the description
- `isUsable` (boolean) - can be used from card tools (or not ready)
- `isPublic` (boolean) - publicly listed
- `isLocked` (boolean) - not editable (can be unlocked)
- `isTemplate` (boolean) - can be used as template for new deck
- `cardCount` (number) - for summary
- `propertyDefs` (CardPropertyDef[]) - card metadata definitions (see below)
- `defaults` (CardInfo) - default metadata for all cards in this revision
- `cards` (CardInfo[]) - metadata for each card in this revision
- `build` (DeckBuild) - configuration/assets for deck generation (see below)
- `output` (DeckOutput) - final/usable deck images

Not part of the database, but the API may return the following:
- `isCurrent` (boolean) - from CardDeckSummary.currentRevision == revision

### Card Info / Card Properties

Each metadata field on a card is defined by a `CardPropertyDef`, with:
- `use` (string) - standard use, see below, default to value of `fieldname` if not specified
- `customFieldname` (string, optional) - programming-style name, used as field name, defaults to value of `use` (if not specified) and generally only needed if multiple subtypes, attributes etc are required.
- `title` (string) - spreadsheet column title
- `description` (string)
- `defaultExport` (boolean) - include in default export
- `sortBy` (number) - to sort e.g. columns

`CardInfo`, has fields to match `use` values (below), plus:
- `custom` - custom fields and values (object)

Standard card properties (`use` options and `CardInfo` fields) 
include *standard metadata*:
- `id` - card ID (of some sort - doesn't change with revisions),
  note "back:..." for a card back (see `back` attribute)
- `revision` - card revision number
- `link` - more info url
- `name` - card name
- `description` - card description
- `slug` - card filename part
- `credits`
- `created` (string/ISO/Date)
- `lastModified` (string/ISO/Date)

*Basic card properties*:
- `width` - nominal physical width, mm
- `height` - nominal physical height, mm
- `sizeName` - e.g. "poker", "bridge", "tarot", [e.g.](https://www.makeplayingcards.com/printed-card-types.aspx)

*Deck-specific card properties*:
- `sortBy` - number to sort by, ascending
- `category` - e.g. like a suit
- `subtype` - e.g. sub-category
- `attribute` - card-specific attribute of some kind, e.g. rank
- `back` - ID (minus 'back:') of card which is the back of this one,
  often also a category/type identifier

*Card generation information*:
- `assetFile` - file (esp. image) used to create the card
- `content` - card-specific text of some kind

*Card output*, i.e. generated card metadata:
- `frontUrl` - full URL of front image
- `backUrl` - full URL of back image
- `frontFile` - filename (only) of front image
- `frontTop`, `frontLeft`, `frontWidth`, `frontHeight` - front image size & offset (optional)
- `backFile` - filename (only) of back image
- `backTop`, `backLeft`, `backWidth`, `backHeight` - back image size & offset (optional)

### Deck Build

Sometimes (but not always) the platform will help to generate 
the cards (draft or final versions).
Information specific to this is help in `DeckBuild`, which has:
- `files`? - a set of asset files used in the build
- `builderId` (string) - identifies specific build plugin to use
- `builderName` (string) - human readable
- `config` (object?) - plugin-specific build configuration
- `lastBuilt` (string/Date)
- `status` (string), "unbuilt", "building", "failed", "built"
- `messages` (string[]) - from last build
- `isDisabled` (boolean) - e.g. after switching to final manual creation.

(to be refined - may need extra CardInfo here generated by the build)

If/when builders can be set/changed,
there will need to be info about build plugins
- `id` - match `DeckBuild.builder`
- `name` - human readable
- ...

Each builder will need an interface, at least
`build`: {revision:`CardDeckRevision`, config:`BuilderConfig`+?} -> {
- `messages` (string[])
- `error` (string) - empty if OK 
- `cards` (CardInfo[]) - extra information for the cards

`BuilderConfig` will need at least:
- `filePath` (string) - uploads file path
- `baseUrl` (string) - public URL base for serving generated files

### Deck Output

Resources required for the deck to be used, mainly final front and back
images.
These may be provided by the user or generated by an automated build.
`DeckOutput`, object with:
- `files`? - a set of final image files (per card or atlas(es))
- `isUserModified` (boolean) - if changed directly by the user
- `atlases` (AtlasInfo) - if texture atlases (below)

(to be refined)

`AtlasInfo` - to match cardographer online - has
- `atlastURLs` (string[])
- `cardX` (number[]) no. cards across atlas
- `cardY` (number[]) no. cards down atlas
- `cardCount` (number)
- `cardInfo` (string[]) card ids
- `builderId` (string) builder Id if autogenerated
Note, get card count and info from the cards.

## Boards

Each `Deck` can have multiple boards. The metadata for all deck-related
boards is edited in a single spreadsheet.

Board metadata - in a spreadsheet :-)

Columns:
- `type` (string) `board`, `zone`, ...?
- `boardId` (string)
- `zoneId` (string) - zone only
- `aka` (string) comma-separated list of alternative IDs
- `text` (string) title or text
- `altText` (string) comma-separated list of alternative text(s), ("..."
  meaning anything starting with that text)
- `exclude` (boolean, default false) exclude cards within this board/zone
- `scaleX` (string) name of X position scale (optional)
- `scaleY` (string) name of Y position scale (optional)

Additional data for specifying appearance, size etc. (for unity and
for AR scanning TBD).

## Design notes

Note, I'm thinking of prototype + cloning model rather than 
regular CRUD. I.e. the only way to make a new Deck would be to clone
an existing CardDeckRevision with isTemplate set, and each new
revision would be clone of the previous revision. The process would
be bootstrapped with a manually added master template or two.

## Sessions

Also a cloning-based approach. So a session marked `isTemplate`
can be copied to make a new session.
A session may move through a number of Stages, each with different 
cards, boards and activities.
Each session has a set of players, who may have different roles.
Each session is scheduled for actual play via a scheduled session.
Each session can have a series of Snapshots, i.e. recorded states.
Each session may also have a more detailed Timeline of events.

A session is the unit of (collaborative) card use. It can take
place over multiple episodes or play (which may or may not correspond to 
different stages), each epsiode having its own State
or Snapshot.

A `Session` has:
- `_id` (string/objectid), unique
- `name` (string)
- `description` (string)
- `credits` (string) mainly for templates
- `owners` (string[]) owner (User) email(s)
- `stages` (SessionStage[]) - array of planned/done Stage definitions
- `currentStage` (number) - index in stages (initially 0)
- `created` (Date/string) ISO date
- `lastModifed` (Date/string)
- `isPublic` (boolean)
- `isTemplate` (boolean), i.e. there to be copied (not played)
- `isArchived` (boolean), i.e. don't allow playing any more
- `sessionType` (string), `unity`, `miro`, `appv1` TBD
- `players` (PlayerInfo[]) info about current player
- `playerTemplates` (PlayerInfo[]) info for new players, taken in order,
  last one repeated

Miro-specific:
- `miroId` (string) board ID
- `miroUrl` (string) board URL
- `miroClaimed` (string/date) when control of miro ID claimed
- `miroIsDefault` (boolean) direct state of this miro board to this session 

- TODO: table state, boards, regions, notes, etc. (unless part of initial
  snapshot)
- TODO session type-specific stuff, e.g. Miro ids, server IPs (unless part
  of ScheduledSession)

Note, see also ScheduledSession, SessionSnapshot

A `SessionStage` is a stage plan, and has:
- `decks` (SessionDeck[]) decks available to spawn 

-  TODO: table state changes?

A `SessionDeck` caches some key deck info:
- `deckId` (string)
- `revision` (number)
- `deckName` (string) - de-norm in case deck can't be found
- `deckCredits` (string) - de-norm ...

`PlayerInfo` has:
- `screenName` (string)
- `role` (string) role name, optional

- TODO: information about cards in hand
- TODO: individual interface options, e.g. use of phone app
- TODO: authentication info/requirements, correlation info (e.g. IP),
  fixed seat number?

At least for the unity-based sessions their use should be
scheduled for resource management.

A `ScheduledSession` has
- `_id` (string)
- `sessionId` (string), FK
- `sessionName` (string) de-norm from Session
- `sessionDescription` (string) de-norm from Session
- `owners` (string[]) User emails, initially copied from Session
- `eventName` (string), optional
- `eventDescription` (string), optional
- `created` (string/Date)
- `lastModified` (string/Date)
- `initialStage` (number, optional) if starting from a specific stage
- `startTime` (string/ISODate) start date/time
- `durationMinutes` (number)
- `maxSeats` (number) max players in session

- TODO: session type-specific stuff, e.g. server IP/path

A `SessionSnapshot` has:
- `_id` (string)
- `sessionId` (string)
- `sessionName` (string) de-norm from Session
- `sessionDescription` (string) de-norm
- `sessionCredits` (string) de-norm
- `sessionType` (string) `unity`, `miro` etc
- `owners` (string[]) User emails, initially copied from Session
- `created` (string/Date) in web app
- `originallyCreated` (string/Date) first recorded
- `snapshotDescription` (string)
- `sessionStage` (number) stage at time of snapshot
- `isPublic` (boolean)
- `isNotForAnalysis` (boolean)

Technology-specific snapshot stuff:
- `legacyId` (string/objectid) mongo _id of legacy import
- `miroId` (string) de-norm
- `miroData` (object) miro export of board
- `appv1Data` (object) appv1 data


- TODO: snapshot data or file reference(s)
- TODO: derived data, e.g. card use

TODO:
- session timeline

## Analysis

`Analysis` has:
- `_id` (string/objectid)
- `name` (string)
- `description` (string)
- `credits` (string)
- `created` (string/ISO date)
- `lastModified` (string/ISO date)
- `owners` (string[]) emails
- `isPublic` (boolean)
- `snapshots` (SessionSnapshotSummary[])

TODO: and...?

`SessionSnapshotSummary` has (subset of SessionSnapshot):
- `_id` (string)
- `sessionId` (string)
- `sessionName` (string) de-norm from Session
- `sessionDescription` (string) de-norm
- `sessionCredits` (string) de-norm
- `sessionType` (string) `unity`, `miro` etc
- `originallyCreated` (string/Date) first recorded
- `snapshotDescription` (string)


